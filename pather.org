* Pather

Pather is a rude library for pathfinding on a 2D grid.

** Pathfinding info
Pathfinding is a graph search problem. The graph in this case is a grid.

Pathfinding algorithms:

  + Breadth First Search
    - explores equally in all directions
  + Dijkstra's Algorithm (Uniform Cost Search)
    - favors lower cost paths
  + A*
    - optimization of Dijkstra's for single target

** Architecture:

*** Examples:
**** OOP:
     pather::Graph* graph = pather::buildGraph(simple_2D_input_structure)
  
     std::vector<std::pair<int, int>>* path =  pather::find(graph, begin_indices, end_indices)

**** type style:
     pather::grid_t* grid = pather::buildGrid(input)

     pather::path_t* path = pather::find(graph, begin, end)

*** Questions and Answers:
  
  + OOP Graph of Nodes approach or just typedefs and free functions?
    
*** Statements:
  + typedefs and free funcs for now, wrap later if necessary
  + the upside of wrapping in classes is only having to build one good call to construct the nested structures  
  + return raw pointers and let callers traffic in ownership
    - do need to tell them "you own this now" however...

** Data choices:

*** Broad
    necessary data and their encoding:
    + x,y of each node
      - indices of grid_t
    + neighbors of each node
      - generated by function of grid_t
	(easy to change from cardinal to 8-way)

*** Node
    + the structures that fill a grid, contain a difficulty value at least
    + is it even necessary if it's just an int wrapper?
      - figure out what other values it might hold otherwise nix it early

*** Grid
    + 2D grid of nodes
    + what structure is it constructed from?
      - if it just takes in and stores a vector<vector<int>> then why bother with a class

*** Path
    std::vector<std::pair<int, int>>
    + list of indices that compose the found path

*** Map
    std::map? std::unordered_map? // benchmark to decide says the MJCPL's only book on cpp
    + some sort of associative mapping of nodes to their predecessor
    + the start node is mapped to itself so when index == index the start has been reached
    + if "Node" isn't actually a structure then maybe just a mapping of std::pair<int, int> to std::pair<int, int>?
      - this is nicely general
      - BUT the actual pairs need to compare equal by value for testing the keys
    + these maps can be memo'd to save later calculation
      - i.e. std::vector<Map> is a list of all mappings for all points, a path can very easily be grabbed out of it
      - BUT if the difficulty of any node in the grid changes, whole list of Maps needs to be recalc'd

** Header:
#+NAME: header
#+HEADER: :tangle src/pather.hpp :main no
#+BEGIN_SRC cpp
#ifndef PATHER_INCLUDE
#define PATHER_INCLUDE
#include <functional>
#include <map>
#include <memory>
#include <queue>
#include <vector>

using index_t = std::pair<int, int>;
using grid_t = std::vector<std::vector<int>>;
using map_t = std::map<index_t, index_t>;
using path_t = std::vector<index_t>;
using node_func_t = std::function<void(int, int, int&)>;

namespace pather {

  std::unique_ptr<grid_t> makeGrid(int w, int h, node_func_t setDifficulty);
  void forEachNode(grid_t& grid, node_func_t nodeFunc);

  bool inGridBounds(const grid_t& grid, index_t index);

  std::unique_ptr<path_t> listNeighbors(const grid_t& grid, index_t index);

  std::unique_ptr<map_t> breadthFirst(const grid_t& grid, index_t start);
  std::unique_ptr<map_t> dijkstras(const grid_t& grid);

  std::unique_ptr<path_t> findPath(const map_t& map); 
}

#endif // PATHER_INCLUDE
#+END_SRC

** Implementation:
#+NAME: implementation
#+HEADER: :tangle src/pather.cpp :main no
#+BEGIN_SRC cpp
#include "pather.hpp"

std::unique_ptr<grid_t> pather::makeGrid(int w, int h, node_func_t setDifficulty) {
  
  std::unique_ptr<grid_t> ugp(new std::vector<std::vector<int>>(w, std::vector<int>(h)));

  forEachNode(*ugp, setDifficulty);

  return ugp;
}

void pather::forEachNode(grid_t& grid, node_func_t nodeFunc) {

  auto x = 0, y = 0;

  for(auto ix = grid.begin(); ix != grid.end(); ++ix) {

    for(auto iy = ix->begin(); iy != ix->end(); ++iy) {

      nodeFunc(x, y, *iy);
      y += 1;  
    }
    x += 1;
  }
}

bool pather::inGridBounds(const grid_t& grid, index_t index) {

  if (index.first > (signed)grid.size() || index.first < 0) return false;
  
  if (index.second > (signed)grid[0].size() || index.second < 0) return false;

  return true;
}

std::unique_ptr<path_t> pather::listNeighbors(const grid_t& grid, index_t index) {

  std::unique_ptr<path_t> neighbors(new path_t());
  
  auto N = index_t(index.first, index.second++);
  auto E = index_t(index.first++, index.second);
  auto S = index_t(index.first, index.second--);
  auto W = index_t(index.first--, index.second);

  if (inGridBounds(grid, N)) neighbors->push_back(N);
  if (inGridBounds(grid, E)) neighbors->push_back(E);
  if (inGridBounds(grid, S)) neighbors->push_back(S);
  if (inGridBounds(grid, W)) neighbors->push_back(W);

  return neighbors;
}

std::unique_ptr<map_t> pather::breadthFirst(const grid_t& grid, index_t start) {

  std::queue<index_t> frontier = std::queue<index_t>();
  frontier.push(start);

  std::unique_ptr<map_t> ump(new map_t());
  ump->insert(std::pair<index_t, index_t>(start, start));

  while (!frontier.empty()) {

    index_t current = frontier.pop();
  }
  

  return ump;
}

#+END_SRC

** Tests:

#+NAME: tests
#+HEADER: :tangle src/tests.cpp 
#+HEADER: :flags '("-std=c++14" "-I/home/userprime/src/pather/src/" "/home/userprime/src/pather/src/pather.o")
#+BEGIN_SRC cpp
#include <iostream>
#include "pather.hpp"

/* Tangle out changes and 'make pather' before executing */

int testGrid() {

  auto flatDifficulty = [](int x, int y, int& n) {
    n = 1;
  };

  std::unique_ptr<grid_t> ugp = pather::makeGrid(12, 24, flatDifficulty);

  std::cout << "Grid is " << ugp->size() << " elements wide and " <<
                             ugp->at(0).size() << " elements tall.\n";
  
  auto total = 0;

  auto totalDifficulty = [&total](int x, int y, int& n) {
    total += n;
  };

  pather::forEachNode(*ugp, totalDifficulty);

  std::cout << "Total of all node difficulties is " << total << "\n";

  return 0;
}

int main(int argc, char** argv) {

  testGrid();

  std::cout << "Tests finished.\n";

  return 0;
}
#+END_SRC

#+RESULTS: tests
| Grid  | is        |  12 | elements | wide         | and |  24 | elements | tall. |
| Total | of        | all | node     | difficulties | is  | 288 |          |       |
| Tests | finished. |     |          |              |     |     |          |       |

