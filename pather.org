* Pather

Pather is a rude library for pathfinding on a 2D grid.

** Pathfinding info
Pathfinding is a graph search problem. The graph in this case is a grid.

Pathfinding algorithms:

  + Breadth First Search
    - explores equally in all directions
  + Dijkstra's Algorithm (Uniform Cost Search)
    - favors lower cost paths
  + A*
    - optimization of Dijkstra's for single target

** Architecture:

*** Examples:
    Some example calls to imagine what the API might look like
**** OOP:
     pather::Graph* graph = pather::buildGraph(simple_2D_input_structure)
  
     std::vector<std::pair<int, int>>* path =  pather::find(graph, begin_indices, end_indices)

**** type style:
     pather::grid_t* grid = pather::buildGrid(input)

     pather::path_t* path = pather::find(graph, begin, end)

*** Questions and Answers:
  
  + OOP Graph of Nodes approach or just typedefs and free functions?
    - decided on free functions
  
*** Statements:
    + wish I had a nice logging system

** Data choices:

*** Broad
    necessary data and their encoding:
    + x,y of each node
      - indices of grid_t
    + neighbors of each node
      - generated by function of grid_t
      - easy(-ish) to change from cardinal to 8-way, just make sure diagonals are weighted properly?

*** Node
    + the structures that fill a grid, contain a difficulty value at least
    + is it even necessary if it's just an int wrapper?
      - figure out what other values it might hold otherwise nix it early
    + it's just an integer representing difficulty, baby
    + the indices are just pulled from the grid structure

*** Grid
    + 2D grid of nodes
    + what structure is it constructed from?
      - if it just takes in and stores a vector<vector<int>> then why bother with a class
    + it's just a vector<vector<int>>, baby

*** Path
    std::vector<std::pair<int, int>>
    + list of indices that compose the found path
    + also used for other indice listing needs, like returning neighbors of a node

*** Map
    std::map? std::unordered_map? // benchmark to decide says the MJCPL's only book on cpp
    + association of nodes to the node by which they are most efficiently reached
    + the start node is mapped to itself so when index == index the start has been reached
    + if "Node" isn't actually an Object then maybe just a mapping of std::pair<int, int> to std::pair<int, int>?
      - this is nicely general
      - BUT the actual pairs need to compare equal by value for testing the keys (they do by default)
    + these maps can be memo'd to save later calculation
      - i.e. std::vector<Map> is a list of all mappings for all start points, a path can very easily be grabbed out of it
      - BUT if the difficulty of any node in the grid changes, whole list of Maps needs to be recalc'd

** Planning:

*** DONE pluralize testing of grids
    CLOSED: [2018-07-04 Wed 12:22]
*** TODO finish out grid fill -> map draw in tests
    and now fix it
*** DONE CHECK ALL grid parsing to make sure row is dominate col is subordinate
    CLOSED: [2018-07-04 Wed 20:00]
*** DONE check grid draw functionality
    CLOSED: [2018-07-04 Wed 12:27]
    it works :o)
*** DONE check grid draw orientation
    CLOSED: [2018-07-04 Wed 12:28]
    it draws out Y ->
*** DONE test breadthfirst
    CLOSED: [2018-07-04 Wed 20:00]
*** TODO fix breadthfirst
    check the state of the structures around the function interfaces


